

GitHub Actions permet dâ€™automatiser le cycle de vie complet de ton application :

- **Build** de lâ€™image Docker avec les bonnes variables.
- **Push** de cette image sur **Docker Hub** (ou autre registry).
- **DÃ©ploiement** automatique sur ton VPS (via SSH).
    

Dans ton cas, le workflow est dÃ©clenchÃ© par une **requÃªte API externe** (via `repository_dispatch`).  
Le frontend envoie un **objet JSON** (contenant les couleurs, le titre du site, lâ€™utilisateurâ€¦) â†’ GitHub Actions utilise ces valeurs comme paramÃ¨tres dynamiques pour builder lâ€™image.

---

## 5.1. PrÃ©sentation du workflow `deploy.yml`

Voici ton fichier simplifiÃ© :

```yaml
name: Deploy Client CMS

on:
  repository_dispatch:
    types: [deploy-site]   # Ã‰vÃ©nement dÃ©clencheur envoyÃ© par une requÃªte POST Ã  lâ€™API GitHub

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    env:
      DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
      DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
      SERVER_HOST: ${{ secrets.SERVER_HOST }}
      SERVER_USER: ${{ secrets.SERVER_USER }}
      SERVER_PASS: ${{ secrets.SERVER_PASS }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Build Docker image
        run: |
          docker build \
            --build-arg REACT_APP_PRIMARY="${{ github.event.client_payload.primary }}" \
            --build-arg REACT_APP_SECONDARY="${{ github.event.client_payload.secondary }}" \
            --build-arg REACT_APP_TITRE_SITE="${{ github.event.client_payload.titreSite }}" \
            --build-arg REACT_APP_USER="${{ github.event.client_payload.user }}" \
            -t $DOCKERHUB_USERNAME/client-cms-${{ github.event.client_payload.user }} .

      - name: Log in to Docker Hub
        run: echo $DOCKERHUB_TOKEN | docker login -u $DOCKERHUB_USERNAME --password-stdin

      - name: Push Docker image
        run: docker push $DOCKERHUB_USERNAME/client-cms-${{ github.event.client_payload.user }}

      - name: Prepare server (install docker if needed)
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ env.SERVER_HOST }}
          username: ${{ env.SERVER_USER }}
          password: ${{ env.SERVER_PASS }}
          script: |
            sudo apt update -y && sudo apt upgrade -y
            if ! command -v docker &> /dev/null
            then
              curl -fsSL https://get.docker.com | sh
            fi

      - name: Run container on server
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ env.SERVER_HOST }}
          username: ${{ env.SERVER_USER }}
          password: ${{ env.SERVER_PASS }}
          script: |
            docker stop client-cms-${{ github.event.client_payload.user }} || true
            docker rm client-cms-${{ github.event.client_payload.user }} || true
            docker run -d -p 80:8080 \
              --name client-cms-${{ github.event.client_payload.user }} \
              $DOCKERHUB_USERNAME/client-cms-${{ github.event.client_payload.user }}
```

---

## 5.2. Ã‰tapes : build â†’ push â†’ deploy

### ğŸ”¹ 1. **DÃ©clencheur (`repository_dispatch`)**

- Le workflow sâ€™exÃ©cute quand une requÃªte POST est envoyÃ©e Ã  lâ€™API GitHub :
    

```bash
curl -X POST \
  -H "Accept: application/vnd.github+json" \
  -H "Authorization: Bearer <TOKEN>" \
  https://api.github.com/repos/<org>/<repo>/dispatches \
  -d '{
    "event_type": "deploy-site",
    "client_payload": {
      "primary": "#f542c2",
      "secondary": "#fcba03",
      "titreSite": "titretest",
      "user": "usertest"
    }
  }'
```

- **`event_type`** = `deploy-site` (doit correspondre au `types: [deploy-site]`).
- **`client_payload`** = donnÃ©es envoyÃ©es par le frontend (variables dynamiques).
    

ğŸ‘‰ Exemple dâ€™usage : un utilisateur configure son site â†’ envoi dâ€™une requÃªte â†’ dÃ©clenchement du pipeline.

---

### ğŸ”¹ 2. **Build de lâ€™image**

```yaml
docker build \
  --build-arg REACT_APP_PRIMARY="${{ github.event.client_payload.primary }}" \
  --build-arg REACT_APP_SECONDARY="${{ github.event.client_payload.secondary }}" \
  --build-arg REACT_APP_TITRE_SITE="${{ github.event.client_payload.titreSite }}" \
  --build-arg REACT_APP_USER="${{ github.event.client_payload.user }}" \
  -t $DOCKERHUB_USERNAME/client-cms-${{ github.event.client_payload.user }} .
```

- On injecte les paramÃ¨tres du **payload** directement comme `--build-arg`.
- Lâ€™image est taggÃ©e de maniÃ¨re unique grÃ¢ce Ã  `client_payload.user`.  
    ğŸ‘‰ Exemple : `cansefr/client-cms-usertest`.
    

---

### ğŸ”¹ 3. **Push sur Docker Hub**

```yaml
echo $DOCKERHUB_TOKEN | docker login -u $DOCKERHUB_USERNAME --password-stdin
docker push $DOCKERHUB_USERNAME/client-cms-${{ github.event.client_payload.user }}
```

- Connexion au Docker Hub avec un **token stockÃ© dans GitHub Secrets**.
- Push de lâ€™image buildÃ©e â†’ disponible depuis ton VPS.
    

---

### ğŸ”¹ 4. **Connexion au serveur & installation de Docker**

```yaml
sudo apt update -y && sudo apt upgrade -y
if ! command -v docker &> /dev/null
then
  curl -fsSL https://get.docker.com | sh
fi
```

- Si Docker nâ€™est pas installÃ© sur le VPS â†’ installation automatique.
- Garantit que le serveur est prÃªt Ã  exÃ©cuter lâ€™image.
    

---

### ğŸ”¹ 5. **DÃ©ploiement & lancement du conteneur**

```yaml
docker stop client-cms-${{ github.event.client_payload.user }} || true
docker rm client-cms-${{ github.event.client_payload.user }} || true
docker run -d -p 80:8080 \
  --name client-cms-${{ github.event.client_payload.user }} \
  $DOCKERHUB_USERNAME/client-cms-${{ github.event.client_payload.user }}
```

- ArrÃªte et supprime tout ancien conteneur du mÃªme nom.
- Lance une nouvelle instance sur **port 80 (hÃ´te)** â†’ **8080 (Nginx)**.
- Le conteneur est nommÃ© dynamiquement (`client-cms-usertest`).
    

ğŸ‘‰ RÃ©sultat : chaque utilisateur peut avoir sa propre version isolÃ©e de lâ€™app.

---

## 5.3. Exemples de configuration (build args dynamiques)

### Exemple 1 : DÃ©ploiement utilisateur `usertest`

Payload envoyÃ© :

```json
{
  "event_type": "deploy-site",
  "client_payload": {
    "primary": "#ff0000",
    "secondary": "#00ff00",
    "titreSite": "Site Rouge & Vert",
    "user": "usertest"
  }
}
```

Pipeline â†’ crÃ©e et dÃ©ploie :

- Image : `cansefr/client-cms-usertest`.
- Conteneur : `client-cms-usertest`.
- Accessible sur : `http://<IP_SERVEUR>` (port 80).
    

---

### Exemple 2 : Nouvel utilisateur `client42`

Payload :

```json
{
  "event_type": "deploy-site",
  "client_payload": {
    "primary": "#123456",
    "secondary": "#654321",
    "titreSite": "Client 42",
    "user": "client42"
  }
}
```

Pipeline â†’ crÃ©e et dÃ©ploie :

- Image : `cansefr/client-cms-client42`.
    
- Conteneur : `client-cms-client42`.
    
- Accessible sur : `http://<IP_SERVEUR>`.
    

---

## âœ… RÃ©sumÃ©

- **DÃ©clenchement** : via `repository_dispatch` (requÃªte API).
- **Build** : lâ€™image est gÃ©nÃ©rÃ©e avec des **variables dynamiques** (`--build-arg`).
- **Push** : upload de lâ€™image sur Docker Hub.
- **Deploy** : connexion SSH au VPS, installation de Docker si besoin, lancement du conteneur.
- **Nom & image uniques** : basÃ©s sur `client_payload.user`.
    

ğŸ‘‰ GrÃ¢ce Ã  ce workflow, tu as une **chaÃ®ne complÃ¨te CI/CD** :  
Frontend â†’ envoi dâ€™un payload â†’ GitHub Actions â†’ build & push Docker â†’ dÃ©ploiement auto sur VPS.

