
## 🎯 Objectif

Notre application (front **ou** back) doit pouvoir envoyer une requête vers l’API GitHub REST pour déclencher un workflow (`repository_dispatch`).

Deux cas :

- **En développement (local)** → les variables sensibles (owner, repo, token) sont stockées dans un `.env` non versionné.
- **En production (build via GitHub Actions)** → il n’y a pas de `.env` dans le repo → il faut donc reconstruire ce fichier à partir des **Secrets GitHub**.
    

---

## 1️⃣ La requête en développement

Dans l’app front, on utilise `fetch` avec les variables exposées par Vite :

```js
fetch(`https://api.github.com/repos/${import.meta.env.VITE_APP_GIT_OWNER}/${import.meta.env.VITE_APP_GIT_REPO}/dispatches`, {
    method: "POST",
    headers: {
        "Accept": "application/vnd.github+json",
        "Content-Type": "application/json",
        "Authorization": `Bearer ${import.meta.env.VITE_APP_GIT_BEARER_PAT}`,
    },
    body: JSON.stringify({
        event_type: "deploy-site",
        client_payload: {
            primary,
            secondary,
            titreSite,
            user,
        },
    }),
});
```

👉 Ici, **toutes les variables sensibles** (`owner`, `repo`, `bearer token`) sont définies dans un fichier `.env` **local** :

```env
VITE_APP_GIT_OWNER=Collect-Verything
VITE_APP_GIT_REPO=produits-cms-ui
VITE_APP_GIT_BEARER_PAT=ghp_xxxxxx
```

⚠️ Ce fichier n’est **jamais versionné** (ajouté au `.gitignore`).

---

## 2️⃣ Pourquoi ça casse en production ?

En **prod**, lors du build de l’image Docker, ce fichier `.env` n’existe pas (il n’est pas dans GitHub).  
Résultat → `import.meta.env.VITE_APP_GIT_OWNER` ou `VITE_APP_GIT_BEARER_PAT` deviennent `undefined`.

👉 Tu te retrouves avec des appels API du style :

```
/repos/undefined/undefined/dispatches
Authorization: Bearer undefined
```

et donc des erreurs `401 Unauthorized` ou `404 Not Found`.

---

## 3️⃣ Solution : Secrets GitHub + génération d’un `.env.production`

Pour résoudre ça :

1. **Définir les variables dans GitHub Secrets** :
    
    - `VITE_APP_GIT_OWNER`
    - `VITE_APP_GIT_REPO`
    - `VITE_APP_GIT_BEARER_PAT`
        

👉 Ces secrets sont stockés dans ton repo GitHub (`Settings` → `Secrets and variables` → `Actions`).

---

2. **Créer un `.env.production` dans ton workflow** avant le build :
    

```yaml
- name: Create .env.production
  run: |
    echo "VITE_APP_GIT_OWNER=${{ secrets.VITE_APP_GIT_OWNER }}" >> .env.production
    echo "VITE_APP_GIT_REPO=${{ secrets.VITE_APP_GIT_REPO }}" >> .env.production
    echo "VITE_APP_GIT_BEARER_PAT=${{ secrets.VITE_APP_GIT_BEARER_PAT }}" >> .env.production
```

👉 Ce fichier sera utilisé par Vite au moment du build Docker.

---

3. **Build avec Docker** :  
    L’image intègre automatiquement ces valeurs (puisque Vite injecte les variables `VITE_*` dans le bundle au build).
    

---


# 🔧 Gestion des variables `VITE_*` pendant le build Docker

### 1. Création du fichier `.env.production` dans la VM GitHub Actions

Lors de l’exécution d’un workflow GitHub Actions, les **Secrets** du dépôt sont injectés dans la VM.  
On génère alors un fichier `.env.production` directement dans le workspace :

```yaml
- name: Create .env.production
  run: |
    echo "VITE_APP_HOST=${{ secrets.VITE_APP_HOST }}" >> .env.production
    echo "VITE_APP_GIT_OWNER=${{ secrets.VITE_APP_GIT_OWNER }}" >> .env.production
    echo "VITE_APP_GIT_REPO=${{ secrets.VITE_APP_GIT_REPO }}" >> .env.production
    echo "VITE_APP_GIT_BEARER_PAT=${{ secrets.VITE_APP_GIT_BEARER_PAT }}" >> .env.production
```

👉 Résultat : la VM possède un `.env.production` contenant toutes les variables nécessaires au build.

---

### 2. Lecture automatique par Vite (ou CRA)

- Les frameworks comme **Vite** ou **Create React App** lisent automatiquement les fichiers d’environnement :
    
    - `.env` (par défaut)
    - `.env.development` (si `NODE_ENV=development`)
    - `.env.production` (si `NODE_ENV=production`)
        
- Lorsqu’on exécute `npm run build` dans le **container Node (stage builder du Dockerfile)** :
    
    - Vite détecte qu’on est en mode production.
    - Il lit `.env.production`.
    - Toutes les variables commençant par `VITE_` sont injectées dans le bundle final (`import.meta.env.VITE_*`).
        

---

### 3. Intégration dans l’image Docker

- Le processus `RUN npm run build` s’exécute **à l’intérieur du container Node** (stage builder).
- Comme `.env.production` a été copié dans le contexte de build (depuis la VM GitHub Actions vers Docker), le container peut le lire.
- Le résultat du build (fichiers statiques optimisés) est ensuite copié dans le stage **Nginx** pour la mise en production.

---

### 4. ⚠️ Attention : valeurs figées au build

Un point crucial à comprendre :

- Les variables `VITE_*` sont **intégrées dans le bundle au moment du build**. 
- Elles **ne sont pas dynamiques à l’exécution** du conteneur en production.
- Si tu modifies un secret ou un paramètre (`VITE_APP_HOST`, etc.), il faut **relancer un nouveau build d’image**.
    

---

## 4️⃣ Comparatif avec la commande `curl`

La requête équivalente **à la main** serait :

```bash
curl -X POST \
  -H "Accept: application/vnd.github+json" \
  -H "Authorization: Bearer $VITE_APP_GIT_BEARER_PAT" \
  https://api.github.com/repos/$VITE_APP_GIT_OWNER/$VITE_APP_GIT_REPO/dispatches \
  -d '{
    "event_type": "deploy-site",
    "client_payload": {
      "primary": "#f542c2",
      "secondary": "#fcba03",
      "titreSite": "titretest",
      "user": "usertest"
    }
  }'
```

👉 En dev, `$VITE_APP_GIT_BEARER_PAT` est chargé depuis ton `.env`.  
👉 En prod, il est injecté automatiquement grâce aux **Secrets GitHub**.

---

## 5️⃣ Points importants à retenir

- `.env` local = pour **dev uniquement**, jamais versionné.
- `.env.production` = généré par le **workflow GitHub** avec les Secrets.
- Vite injecte automatiquement toutes les variables qui commencent par `VITE_` dans `import.meta.env`.
- Si tu oublies la génération du `.env.production` → tu auras des `undefined` en prod.
    

---

## ✅ Résumé

- En **local** : fichier `.env` → `import.meta.env` → fetch OK.
- En **prod (CI/CD)** : secrets GitHub → création `.env.production` → build Docker → `import.meta.env` utilisable.


1. Les secrets GitHub sont transformés en `.env.production` dans la VM.    
2. `npm run build` lit ce fichier et injecte les valeurs `VITE_*` dans le code.
3. Docker assemble l’image avec les fichiers déjà configurés.
4. Les valeurs sont **figées** dans l’image → il faut rebuild en cas de changement.
    

---

👉 Avec ça, ton front/back peut **toujours déclencher un workflow GitHub via API**, que ce soit en dev ou en prod, sans jamais exposer les secrets dans ton repo.


Voici un exemple de l’action, côté application, qui déclenche le workflow de déploiement sur le dépôt du site concerné :


```yaml
name: Deploy React App to VPS  
  
on:  
  push:  
    branches:  
      - main  
  
jobs:  
  build-and-deploy:  
    runs-on: ubuntu-latest  
  
    steps:  
      - name: Checkout code  
        uses: actions/checkout@v3  
  
      - name: Create .env.production  
        run: |  
          echo "VITE_APP_HOST=${{ secrets.VITE_APP_HOST }}" >> .env.production          
          echo "VITE_APP_GIT_OWNER=${{ secrets.VITE_APP_GIT_OWNER }}" >> .env.production          
          echo "VITE_APP_GIT_REPO=${{ secrets.VITE_APP_GIT_REPO }}" >> .env.production          
          echo "VITE_APP_GIT_BEARER_PAT=${{ secrets.VITE_APP_GIT_BEARER_PAT }}" >> .env.production  
          
      - name: Log in to Docker Hub  
        uses: docker/login-action@v2  
        with:  
          username: ${{ secrets.DOCKERHUB_USERNAME }}  
          password: ${{ secrets.DOCKERHUB_TOKEN }}  
  
      - name: Build and push Docker image  
        uses: docker/build-push-action@v5  
        with:  
          context: .  
          push: true  
          tags: cansefr/my-app:latest  
          platforms: linux/amd64  
  
      - name: Deploy to VPS  
        uses: appleboy/ssh-action@v1.0.3  
        with:  
          host: ${{ secrets.SERVER_IP }}  
          username: ${{ secrets.SERVER_USER }}  
          password: ${{ secrets.SERVER_PASSWORD }}  
          script: |  
            cd /home/root/my-app            
            docker pull cansefr/my-app:latest            
            docker compose down            
            docker compose up -d
```