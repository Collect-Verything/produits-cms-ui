
## ðŸŽ¯ Objectif

Notre application (front **ou** back) doit pouvoir envoyer une requÃªte vers lâ€™API GitHub REST pour dÃ©clencher un workflow (`repository_dispatch`).

Deux cas :

- **En dÃ©veloppement (local)** â†’ les variables sensibles (owner, repo, token) sont stockÃ©es dans un `.env` non versionnÃ©.
- **En production (build via GitHub Actions)** â†’ il nâ€™y a pas de `.env` dans le repo â†’ il faut donc reconstruire ce fichier Ã  partir des **Secrets GitHub**.
    

---

## 1ï¸âƒ£ La requÃªte en dÃ©veloppement

Dans lâ€™app front, on utilise `fetch` avec les variables exposÃ©es par Vite :

```js
fetch(`https://api.github.com/repos/${import.meta.env.VITE_APP_GIT_OWNER}/${import.meta.env.VITE_APP_GIT_REPO}/dispatches`, {
    method: "POST",
    headers: {
        "Accept": "application/vnd.github+json",
        "Content-Type": "application/json",
        "Authorization": `Bearer ${import.meta.env.VITE_APP_GIT_BEARER_PAT}`,
    },
    body: JSON.stringify({
        event_type: "deploy-site",
        client_payload: {
            primary,
            secondary,
            titreSite,
            user,
        },
    }),
});
```

ðŸ‘‰ Ici, **toutes les variables sensibles** (`owner`, `repo`, `bearer token`) sont dÃ©finies dans un fichier `.env` **local** :

```env
VITE_APP_GIT_OWNER=Collect-Verything
VITE_APP_GIT_REPO=produits-cms-ui
VITE_APP_GIT_BEARER_PAT=ghp_xxxxxx
```

âš ï¸ Ce fichier nâ€™est **jamais versionnÃ©** (ajoutÃ© au `.gitignore`).

---

## 2ï¸âƒ£ Pourquoi Ã§a casse en production ?

En **prod**, lors du build de lâ€™image Docker, ce fichier `.env` nâ€™existe pas (il nâ€™est pas dans GitHub).  
RÃ©sultat â†’ `import.meta.env.VITE_APP_GIT_OWNER` ou `VITE_APP_GIT_BEARER_PAT` deviennent `undefined`.

ðŸ‘‰ Tu te retrouves avec des appels API du style :

```
/repos/undefined/undefined/dispatches
Authorization: Bearer undefined
```

et donc des erreurs `401 Unauthorized` ou `404 Not Found`.

---

## 3ï¸âƒ£ Solution : Secrets GitHub + gÃ©nÃ©ration dâ€™un `.env.production`

Pour rÃ©soudre Ã§a :

1. **DÃ©finir les variables dans GitHub Secrets** :
    
    - `VITE_APP_GIT_OWNER`
    - `VITE_APP_GIT_REPO`
    - `VITE_APP_GIT_BEARER_PAT`
        

ðŸ‘‰ Ces secrets sont stockÃ©s dans ton repo GitHub (`Settings` â†’ `Secrets and variables` â†’ `Actions`).

---

2. **CrÃ©er un `.env.production` dans ton workflow** avant le build :
    

```yaml
- name: Create .env.production
  run: |
    echo "VITE_APP_GIT_OWNER=${{ secrets.VITE_APP_GIT_OWNER }}" >> .env.production
    echo "VITE_APP_GIT_REPO=${{ secrets.VITE_APP_GIT_REPO }}" >> .env.production
    echo "VITE_APP_GIT_BEARER_PAT=${{ secrets.VITE_APP_GIT_BEARER_PAT }}" >> .env.production
```

ðŸ‘‰ Ce fichier sera utilisÃ© par Vite au moment du build Docker.

---

3. **Build avec Docker** :  
    Lâ€™image intÃ¨gre automatiquement ces valeurs (puisque Vite injecte les variables `VITE_*` dans le bundle au build).
    

---


# ðŸ”§ Gestion des variables `VITE_*` pendant le build Docker

### 1. CrÃ©ation du fichier `.env.production` dans la VM GitHub Actions

Lors de lâ€™exÃ©cution dâ€™un workflow GitHub Actions, les **Secrets** du dÃ©pÃ´t sont injectÃ©s dans la VM.  
On gÃ©nÃ¨re alors un fichier `.env.production` directement dans le workspace :

```yaml
- name: Create .env.production
  run: |
    echo "VITE_APP_HOST=${{ secrets.VITE_APP_HOST }}" >> .env.production
    echo "VITE_APP_GIT_OWNER=${{ secrets.VITE_APP_GIT_OWNER }}" >> .env.production
    echo "VITE_APP_GIT_REPO=${{ secrets.VITE_APP_GIT_REPO }}" >> .env.production
    echo "VITE_APP_GIT_BEARER_PAT=${{ secrets.VITE_APP_GIT_BEARER_PAT }}" >> .env.production
```

ðŸ‘‰ RÃ©sultat : la VM possÃ¨de un `.env.production` contenant toutes les variables nÃ©cessaires au build.

---

### 2. Lecture automatique par Vite (ou CRA)

- Les frameworks comme **Vite** ou **Create React App** lisent automatiquement les fichiers dâ€™environnement :
    
    - `.env` (par dÃ©faut)
    - `.env.development` (si `NODE_ENV=development`)
    - `.env.production` (si `NODE_ENV=production`)
        
- Lorsquâ€™on exÃ©cute `npm run build` dans le **container Node (stage builder du Dockerfile)** :
    
    - Vite dÃ©tecte quâ€™on est en mode production.
    - Il lit `.env.production`.
    - Toutes les variables commenÃ§ant par `VITE_` sont injectÃ©es dans le bundle final (`import.meta.env.VITE_*`).
        

---

### 3. IntÃ©gration dans lâ€™image Docker

- Le processus `RUN npm run build` sâ€™exÃ©cute **Ã  lâ€™intÃ©rieur du container Node** (stage builder).
- Comme `.env.production` a Ã©tÃ© copiÃ© dans le contexte de build (depuis la VM GitHub Actions vers Docker), le container peut le lire.
- Le rÃ©sultat du build (fichiers statiques optimisÃ©s) est ensuite copiÃ© dans le stage **Nginx** pour la mise en production.

---

### 4. âš ï¸ Attention : valeurs figÃ©es au build

Un point crucial Ã  comprendre :

- Les variables `VITE_*` sont **intÃ©grÃ©es dans le bundle au moment du build**. 
- Elles **ne sont pas dynamiques Ã  lâ€™exÃ©cution** du conteneur en production.
- Si tu modifies un secret ou un paramÃ¨tre (`VITE_APP_HOST`, etc.), il faut **relancer un nouveau build dâ€™image**.
    

---

## 4ï¸âƒ£ Comparatif avec la commande `curl`

La requÃªte Ã©quivalente **Ã  la main** serait :

```bash
curl -X POST \
  -H "Accept: application/vnd.github+json" \
  -H "Authorization: Bearer $VITE_APP_GIT_BEARER_PAT" \
  https://api.github.com/repos/$VITE_APP_GIT_OWNER/$VITE_APP_GIT_REPO/dispatches \
  -d '{
    "event_type": "deploy-site",
    "client_payload": {
      "primary": "#f542c2",
      "secondary": "#fcba03",
      "titreSite": "titretest",
      "user": "usertest"
    }
  }'
```

ðŸ‘‰ En dev, `$VITE_APP_GIT_BEARER_PAT` est chargÃ© depuis ton `.env`.  
ðŸ‘‰ En prod, il est injectÃ© automatiquement grÃ¢ce aux **Secrets GitHub**.

---

## 5ï¸âƒ£ Points importants Ã  retenir

- `.env` local = pour **dev uniquement**, jamais versionnÃ©.
- `.env.production` = gÃ©nÃ©rÃ© par le **workflow GitHub** avec les Secrets.
- Vite injecte automatiquement toutes les variables qui commencent par `VITE_` dans `import.meta.env`.
- Si tu oublies la gÃ©nÃ©ration du `.env.production` â†’ tu auras des `undefined` en prod.
    

---

## âœ… RÃ©sumÃ©

- En **local** : fichier `.env` â†’ `import.meta.env` â†’ fetch OK.
- En **prod (CI/CD)** : secrets GitHub â†’ crÃ©ation `.env.production` â†’ build Docker â†’ `import.meta.env` utilisable.


1. Les secrets GitHub sont transformÃ©s en `.env.production` dans la VM.    
2. `npm run build` lit ce fichier et injecte les valeurs `VITE_*` dans le code.
3. Docker assemble lâ€™image avec les fichiers dÃ©jÃ  configurÃ©s.
4. Les valeurs sont **figÃ©es** dans lâ€™image â†’ il faut rebuild en cas de changement.
    

---

ðŸ‘‰ Avec Ã§a, ton front/back peut **toujours dÃ©clencher un workflow GitHub via API**, que ce soit en dev ou en prod, sans jamais exposer les secrets dans ton repo.


Voici un exemple de lâ€™action, cÃ´tÃ© application, qui dÃ©clenche le workflow de dÃ©ploiement sur le dÃ©pÃ´t du site concernÃ© :


```yaml
name: Deploy React App to VPS  
  
on:  
  push:  
    branches:  
      - main  
  
jobs:  
  build-and-deploy:  
    runs-on: ubuntu-latest  
  
    steps:  
      - name: Checkout code  
        uses: actions/checkout@v3  
  
      - name: Create .env.production  
        run: |  
          echo "VITE_APP_HOST=${{ secrets.VITE_APP_HOST }}" >> .env.production          
          echo "VITE_APP_GIT_OWNER=${{ secrets.VITE_APP_GIT_OWNER }}" >> .env.production          
          echo "VITE_APP_GIT_REPO=${{ secrets.VITE_APP_GIT_REPO }}" >> .env.production          
          echo "VITE_APP_GIT_BEARER_PAT=${{ secrets.VITE_APP_GIT_BEARER_PAT }}" >> .env.production  
          
      - name: Log in to Docker Hub  
        uses: docker/login-action@v2  
        with:  
          username: ${{ secrets.DOCKERHUB_USERNAME }}  
          password: ${{ secrets.DOCKERHUB_TOKEN }}  
  
      - name: Build and push Docker image  
        uses: docker/build-push-action@v5  
        with:  
          context: .  
          push: true  
          tags: cansefr/my-app:latest  
          platforms: linux/amd64  
  
      - name: Deploy to VPS  
        uses: appleboy/ssh-action@v1.0.3  
        with:  
          host: ${{ secrets.SERVER_IP }}  
          username: ${{ secrets.SERVER_USER }}  
          password: ${{ secrets.SERVER_PASSWORD }}  
          script: |  
            cd /home/root/my-app            
            docker pull cansefr/my-app:latest            
            docker compose down            
            docker compose up -d
```