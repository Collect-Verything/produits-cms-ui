

## 6.1. Pourquoi un PAT est nécessaire

Un **Personal Access Token (PAT)** est requis car :

- Ton dépôt est **privé** → une simple requête HTTP anonyme (`curl`) renvoie `404 Not Found`.
- Le workflow est déclenché via un **événement `repository_dispatch`**, donc on doit **authentifier** la requête auprès de l’API GitHub.
- L’authentification standard (login/mdp) n’existe plus → seul un **Bearer Token** (PAT) est accepté.

👉 Sans PAT ou avec un PAT mal configuré → erreurs fréquentes :

- `401 Unauthorized` → mauvais token ou expiré.
- `403 Resource not accessible by personal access token` → manque de permissions.
- `404 Not Found` → repo privé inaccessible au token.
    

---

## 6.2. Création d’un PAT fine-grained

GitHub recommande d’utiliser des **fine-grained tokens** (plus sécurisés que les anciens "classic PAT").

➡️ Étapes :

1. Aller sur : [https://github.com/settings/tokens?type=beta](https://github.com/settings/tokens?type=beta)
2. **Token name** : ex. `client-deploy`.
3. **Expiration** : mettre une durée raisonnable (éviter "No expiration").
4. **Resource owner** :
    - Choisir ton **organisation (`Collect-Verything`)**, pas seulement ton compte perso.
    - Sinon → tu auras un `403` sur les repos privés de l’orga.
5. **Repository access** :
    - **Only select repositories** → sélectionner `produits-cms-ui`.
    - Évite "All repositories" si inutile.
        

---

## 6.3. Droits & permissions minimales

Pour que le token permette de déclencher le workflow, il faut activer les droits suivants :

### 🔹 Repository permissions

- **Actions → Read and write** ✅ (pour autoriser le déclenchement de workflows).
- **Contents → Read and write** ✅ (pour accéder au code si besoin pendant le workflow).
- **Metadata → Read-only** ✅ (obligatoire par défaut, rien à changer).
    

### 🔹 Organization permissions

- Pas nécessaire ici (sauf si tu veux gérer d’autres aspects globaux de l’orga).
    

👉 Sans `Actions: Read and write`, tu auras :

```json
{ "message": "Resource not accessible by personal access token", "status": 403 }
```

👉 Sans `Contents: Read and write`, tu ne pourras pas `checkout` le code dans ton workflow.

---

## 6.4. Ajout en secret GitHub Actions

Une fois ton PAT généré, tu dois le stocker en **secret GitHub Actions** :

➡️ Étapes :

1. Aller dans ton dépôt `produits-cms-ui` → **Settings** → **Secrets and variables** → **Actions**.
2. Ajouter un secret nommé par ex. :
    - `DEPLOY_PAT` = ton token GitHub.
3. Dans ton `curl`, utilise ce token :
    

```bash
curl -X POST \
  -H "Accept: application/vnd.github+json" \
  -H "Authorization: Bearer $DEPLOY_PAT" \
  https://api.github.com/repos/Collect-Verything/produits-cms-ui/dispatches \
  -d '{
    "event_type": "deploy-site",
    "client_payload": {
      "primary": "#f542c2",
      "secondary": "#fcba03",
      "titreSite": "titretest",
      "user": "usertest"
    }
  }'
```
---

## 6.5. Vérifications et checks utiles

Quand on configure un PAT et qu’on a des erreurs, il existe plusieurs requêtes **de diagnostic** à lancer avec `curl`.

### 🔹 Vérifier l’accès au repo (lecture simple)

```bash
curl -H "Authorization: Bearer <TOKEN>" \
  https://api.github.com/repos/Collect-Verything/produits-cms-ui
```

👉 Résultats possibles :

- `200 OK` → le token a bien accès au repo.
- `404 Not Found` → le repo est privé OU le token n’a pas accès à ce repo.
- `401 Unauthorized` → token invalide ou expiré.
    

---

### 🔹 Vérifier que le token est valide (test API basique)

```bash
curl -H "Authorization: Bearer <TOKEN>" https://api.github.com/user
```

👉 Résultats possibles 
- Retourne un JSON avec ton `login` → ✅ le token est valide.
- `401 Unauthorized` → token incorrect ou expiré.
    

---

### 🔹 Tester l’événement `repository_dispatch`

C’est la commande finale pour déclencher le workflow :

```bash
curl -X POST \
  -H "Accept: application/vnd.github+json" \
  -H "Authorization: Bearer <TOKEN>" \
  https://api.github.com/repos/Collect-Verything/produits-cms-ui/dispatches \
  -d '{
    "event_type": "deploy-site",
    "client_payload": {
      "primary": "#f542c2",
      "secondary": "#fcba03",
      "titreSite": "titretest",
      "user": "usertest"
    }
  }'
```

👉 Résultats possibles :

- `204 No Content` → succès (l’événement a été créé).
- `403 Resource not accessible by personal access token` → permissions manquantes (`Actions` ou `Contents`).
- `404 Not Found` → repo privé inaccessible → revoir owner et accès.
    

---

### 🔹 Pièges rencontrés dans ton cas

1. **404 au début** → le repo était privé → le token n’était pas lié à l’organisation.
2. **401 ensuite** → mauvais token / expiré.
3. **403 après coup** → permissions du PAT pas suffisantes (il manquait `Actions: Read and write`).
    

Une fois corrigé → `204 No Content` → workflow bien déclenché ✅.

----
## ✅ Résumé complet : PAT GitHub & erreurs courantes

- Un **PAT (Personal Access Token)** est **obligatoire** pour accéder à un repo **privé** et déclencher un événement `repository_dispatch`.
    
- **Vérifications rapides à faire avec `curl`** :
    
    - `GET /user` → vérifie si le token est valide.
    - `GET /repos/:owner/:repo` → vérifie si le token a accès au repo.
    - `POST /repos/:owner/:repo/dispatches` → teste le déclenchement du workflow.
        
- **Erreurs classiques rencontrées** :
    
    - **404 Not Found** → le repo est privé ou le token n’a pas accès à l’organisation.
    - **401 Unauthorized** → token invalide ou expiré.
    - **403 Resource not accessible by PAT** → permissions insuffisantes (résolu en activant `Actions: Read and write`).
        
- **Permissions minimales à donner au PAT** :
    
    - Repository → **Actions: Read and write** ✅
    - Repository → **Contents: Read and write** ✅
    - Repository → **Metadata: Read-only** (par défaut) ✅
        
- Avec un **PAT fine-grained bien configuré** :
    
    - Le `repository_dispatch` peut être déclenché depuis ton **frontend** (via `fetch` ou `axios`) ou un simple `curl`.
    - Le workflow GitHub reçoit le `client_payload` et lance le **build + push + deploy** Docker automatiquement.
        

---

⚡ Grâce à ces règles, tu as une **procédure de debug complète** pour identifier et corriger toute erreur (`401`, `403`, `404`) et ne plus être bloqué sur les Bearer Tokens GitHub.


---

# 🔄 Schéma du flux CI/CD avec PAT GitHub

```
[ Frontend / Client ]
         |
         |  (fetch / axios / curl)
         |  Envoi JSON (client_payload) + PAT
         v
[ API GitHub - repository_dispatch ]
         |
         |  Vérifie le PAT :
         |   - Token valide ? ✅
         |   - Accès au repo ? ✅
         |   - Permissions suffisantes ? ✅
         v
[ GitHub Actions Workflow (deploy.yml) ]
         |
         |  Étapes :
         |   1. Checkout code
         |   2. Build image Docker (--build-arg avec client_payload)
         |   3. Push image sur Docker Hub
         |   4. SSH vers VPS
         |   5. docker run (Nginx)
         v
[ Docker Hub Registry ]
         |
         |  Image disponible : namespace/client-cms-<user>
         v
[ VPS / Serveur Ionos ]
         |
         |  docker run -p 80:8080
         v
[ Application React (Nginx) ]
   => http://<IP_SERVEUR>/
```

---

## ✅ Lecture rapide

1. **Frontend** → envoie une requête POST avec le **Bearer Token** et le **payload**.
2. **GitHub API** → valide le PAT et déclenche l’événement `repository_dispatch`.
3. **GitHub Actions** → build l’image Docker personnalisée, push sur Docker Hub et déploie via SSH.
4. **Docker Hub** → stocke l’image (taggée dynamiquement par utilisateur).
5. **VPS** → récupère l’image, lance le conteneur et expose l’app sur le port 80.
    
