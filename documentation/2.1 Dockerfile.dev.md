

En mode **développement**, l’objectif est de pouvoir coder dans l’application React et voir les changements **instantanément** grâce au hot reload.  
Pour cela, on n’utilise pas Nginx mais directement le serveur de développement fourni par **Create React App** (`react-scripts start` => *CRA*) .

---

## 🔹 Contenu du `Dockerfile.dev`

```dockerfile
# ===========================
# Dev: React avec hot reload
# ===========================
ARG NODE_VERSION=22.14.0-alpine
FROM node:${NODE_VERSION}

WORKDIR /app

# Installer les dépendances
COPY package.json package-lock.json ./
RUN --mount=type=cache,target=/root/.npm npm ci

# Copier le reste du code
COPY . .

# Important : écouter sur toutes les interfaces
ENV HOST=0.0.0.0
EXPOSE 3000

# Lancer le serveur de dev (CRA)
CMD ["npm", "start"]
```
### 🔹 Décomposition

##### 1. `--mount=type=cache,target=/root/.npm`

- C’est une **option avancée de BuildKit** (le moteur de build de Docker).
- Elle crée un **cache persistant** qui survit aux builds successifs.
- Ici, le cache est stocké dans `/root/.npm`, c’est-à-dire là où `npm` garde ses paquets téléchargés.

👉 Résultat : lors des prochains `docker build`, npm ne retélécharge pas toutes les dépendances → build **beaucoup plus rapide**.
⚠️ Attention : ce cache est **local au builder**. Si tu build sur GitHub Actions, le cache y sera différent de ta machine locale.

---

##### 2. `npm ci`

- `npm ci` = _clean install_.
- Contrairement à `npm install`, il se base **strictement** sur le fichier `package-lock.json`.
- Avantages :
    - **Reproductibilité garantie** → toujours les mêmes versions de dépendances.
    - **Plus rapide** → supprime `node_modules` et réinstalle directement ce qui est listé.
    - Idéal pour les **CI/CD pipelines** et builds en Docker.

Source : https://docs.npmjs.com/cli/v9/commands/npm-ci
        
---

##### 🔹 Exemple de workflow

Sans cache + `npm install` → à chaque build :
1. Docker télécharge toutes les dépendances depuis zéro.
2. Le build prend beaucoup de temps.
Avec cache + `npm ci` →
3. Docker réutilise les paquets déjà téléchargés (si pas de changement dans `package-lock.json`).
4. Build quasi instantané.

---
##### 🔹 Résumé

Cette ligne :

```dockerfile
RUN --mount=type=cache,target=/root/.npm npm ci
```

- **Optimise** le build en mettant en cache les paquets NPM.
- **Garantit** que le build utilise exactement les dépendances définies dans `package-lock.json`.
- Est particulièrement utile en **CI/CD** (GitHub Actions, etc.).
    

---
#### ⚖️ Comparatif `npm install` vs `npm ci` (avec/sans cache)

| Commande                | Comportement                                                                                  | Rapidité                                              | Reproductibilité                         | Cas d’usage recommandé                                      |
| ----------------------- | --------------------------------------------------------------------------------------------- | ----------------------------------------------------- | ---------------------------------------- | ----------------------------------------------------------- |
| **npm install**         | Installe les dépendances listées dans `package.json`. Peut mettre à jour `package-lock.json`. | ⏳ Plus lent (résolution des versions à chaque build). | ❌ Pas garanti (versions peuvent varier). | Développement local, quand tu ajoutes ou modifies des libs. |
| **npm ci**              | Supprime `node_modules` puis installe **exactement** les dépendances de `package-lock.json`.  | ⚡ Plus rapide que `install`.                          | ✅ Toujours identique (versions figées).  | CI/CD, builds Docker, prod.                                 |
| **npm install + cache** | Les paquets téléchargés sont réutilisés au prochain build.                                    | ⏳ Toujours plus lent que `ci` (résolution).           | ❌ Toujours non figé.                     | Rarement utile.                                             |
| **npm ci + cache**      | Réutilise les paquets déjà téléchargés **et** suit strictement `package-lock.json`.           | 🚀 Ultra rapide.                                      | ✅ Garanti.                               | ⭐ Meilleur choix pour Docker + CI/CD.                       |

---

##### ✅ Conclusion pour Docker

La ligne :
```dockerfile
RUN --mount=type=cache,target=/root/.npm npm ci
```
combine **le meilleur des deux mondes** :
- `npm ci` → installation fiable et reproductible
- `--mount=cache` → build rapide, même après plusieurs exécutions
    

---

## 🔹 Explications

- **HOST=0.0.0.0** : obligatoire pour que l’app soit accessible depuis l’extérieur du conteneur (sinon elle reste accessible uniquement en `localhost` interne).
- **EXPOSE 3000** : CRA écoute sur le port 3000 en mode dev.
- **npm start** : démarre le serveur de dev avec hot reload.
- On utilise `npm ci` plutôt que `npm install` pour garantir une installation reproductible des dépendances (basée sur `package-lock.json`).

---

## 🔹 Utilisation avec docker-compose

Dans `compose.yaml` :

```yaml
client-dev:
  build:
    context: .
    dockerfile: Dockerfile.dev
  ports:
    - 3000:3000
  volumes:
    - .:/app
    - /app/node_modules
  environment:
    NODE_ENV: development
    HOST: 0.0.0.0
```

- **.:/app** → monte ton code source dans le conteneur
- **/app/node_modules** → évite les conflits entre dépendances locales et celles du conteneur

---

## 🔹 Commandes utiles

### Lancer le service dev avec hot reload :

```bash
docker compose up client-dev
```

👉 Application accessible sur : [http://localhost:3000](http://localhost:3000/)

---

✅ Ce `Dockerfile.dev` est donc dédié uniquement au **développement**, contrairement au `Dockerfile` classique qui sert la version optimisée avec Nginx.
